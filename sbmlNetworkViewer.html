<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8">
    <title>SBML Network Viewer</title>
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script> 
    <script src="//cdnjs.cloudflare.com/ajax/libs/d3/2.10.0/d3.v2.min.js"></script>

    <style type="text/css">

path.link {
  fill: none;
  stroke: #666;
  stroke-width: 1.5px;
}

marker#licensing {
  fill: green;
}

path.link.licensing {
  stroke: green;
}

path.link.resolved {
  stroke-dasharray: 0,2 1;
}

circle {
  fill: #ccc;
  stroke: #333;
  stroke-width: 1.5px;
}

text {
  font: 10px sans-serif;
  pointer-events: none;
}

text.shadow {
  stroke: #fff;
  stroke-width: 3px;
  stroke-opacity: .8;
}

circle.node {
  cursor: pointer;
  stroke: #3182bd;
  stroke-width: 1.5px;
}

line.link {
  fill: none;
  stroke: #9ecae1;
  stroke-width: 1.5px;
}
    </style>
  </head>
  <body>
    <h1>SBML Reaction Viewer</h1>
    
    <p>This makes a force directed graph from species within an SBML model. </p> 
    <p>*This is just a prototype, linkages are drawn from every reactant to every product in each reaction.</p>
    
    <p>Input SBML Below:</p>    
    <textarea rows="10" cols="30"></textarea>
    <br/>
    <button type="button">View Reaction Network</button>
    <br/>
    <script type="text/javascript">

var sbmlString = '<?xml version="1.0" encoding="UTF-8"?> <sbml xmlns="http://www.sbml.org/sbml/level2/version4" level="2" version="4"> <model metaid="_case00007" id="case00007" name="case00007"> <listOfCompartments> <compartment id="compartment" name="compartment" size="1" units="volume"/> </listOfCompartments> <listOfSpecies> <species id="S1" name="S1" compartment="compartment" initialAmount="0.015" substanceUnits="substance" boundaryCondition="true"/> <species id="S2" name="S2" compartment="compartment" initialAmount="0.015" substanceUnits="substance"/> </listOfSpecies> <listOfParameters> <parameter id="k1" name="k1" value="0.5"/> <parameter id="k2" name="k2" value="0.25"/> </listOfParameters> <listOfReactions> <reaction id="reaction1" name="reaction1" reversible="false" fast="false"> <listOfReactants> <speciesReference species="S1"/> </listOfReactants> <listOfProducts> <speciesReference species="S2"/> </listOfProducts> <kineticLaw> <math xmlns="http://www.w3.org/1998/Math/MathML"> <apply> <times/> <ci> compartment </ci> <ci> k1 </ci> <ci> S1 </ci> </apply> </math> </kineticLaw> </reaction> <reaction id="reaction2" name="reaction2" reversible="false" fast="false"> <listOfReactants> <speciesReference species="S2"/> </listOfReactants> <listOfProducts> <speciesReference species="S1"/> </listOfProducts> <kineticLaw> <math xmlns="http://www.w3.org/1998/Math/MathML"> <apply> <times/> <ci> compartment </ci> <ci> k2 </ci> <ci> S2 </ci> </apply> </math> </kineticLaw> </reaction> </listOfReactions> </model> </sbml>';

$("textarea").text(sbmlString);

$("button").click(function(){
    str = $("textarea").val();
    $("p").hide("slow");
    $("textarea").hide("slow");
    $(this).hide("slow");
                   
    sbmlDoc = $.parseXML(str);
    $sbmlDoc = $(sbmlDoc);
    var links = [];
    
    $sbmlDoc.find("reaction").each(function(n){ 
        a = this.childNodes;
    	lor = a[1]; // listOfReactants 
    	lop = a[3]; // listOfProducts
    	
    	reactants = lor.getElementsByTagName("speciesReference")
        products = lop.getElementsByTagName("speciesReference")
//    	for (i=0; i<reactants.length; i++){
//    		a=reactants[i].getAttribute("species");
//            for (j=0; j<products.length; j++){
//                b=products[j].getAttribute("species");
//                links.push({source: a, target: b, type: "suit"});
//            }
//    	}
        var listReactantNames = [];
        var listProductNames = [];
        for (i=0; i<reactants.length; i++){
    		listReactantNames.push(reactants[i].getAttribute("species")); 
    	}
        for (j=0; j<products.length; j++){
            listProductNames.push(products[j].getAttribute("species"));
        }
        
        // names of the reactants and products
        //r1 = 'reaction'+n+'r';
        //r2 = 'reaction'+n+'p';
        r1 = 'r'+n;
        r2 = 'p'+n;
        
        links.push({source: r1, target: r2, type: 'suit'});
        
        listReactantNames.forEach( function(i) {
            links.push({source: i, target: r1, type: 'suit'});
        });
        
        listProductNames.forEach( function(i) {
            links.push({source: r2, target: i, type: 'suit'});
        });
        
        //links.push({source: a, target: b, type: "suit"});

        
    });
    
    var nodes = {};
    
    // Compute the distinct nodes from the links.
    links.forEach(function(link) {
      link.source = nodes[link.source] || (nodes[link.source] = {name: link.source});
      link.target = nodes[link.target] || (nodes[link.target] = {name: link.target});
    });
    
    var w = 960,
        h = 500;
    
    var force = d3.layout.force()
        .nodes(d3.values(nodes))
        .links(links)
        .size([w, h])
        .linkDistance(60)
        .charge(-300)
        .on("tick", tick)
        .start();

//    var force = d3.layout.force()
//    .on("tick", tick)
//    .size([w, h])
//    .start();

    
    var svg = d3.select("body").append("svg:svg")
        .attr("width", w)
        .attr("height", h);
    
    // Per-type markers, as they don't inherit styles.
    svg.append("svg:defs").selectAll("marker")
        .data(["suit", "licensing", "resolved"])
      .enter().append("svg:marker")
        .attr("id", String)
        .attr("viewBox", "0 -5 10 10")
        .attr("refX", 15)
        .attr("refY", -1.5)
        .attr("markerWidth", 6)
        .attr("markerHeight", 6)
        .attr("orient", "auto")
      .append("svg:path")
        .attr("d", "M0,-5L10,0L0,5");
    
    var path = svg.append("svg:g").selectAll("path")
        .data(force.links())
      .enter().append("svg:path")
        .attr("class", function(d) { return "link " + d.type; })
        .attr("marker-end", function(d) { return "url(#" + d.type + ")"; });
    
    var circle = svg.append("svg:g").selectAll("circle")
        .data(force.nodes())
      .enter().append("svg:circle")
        .attr("r", 6)
        .call(force.drag);
    
    var text = svg.append("svg:g").selectAll("g")
        .data(force.nodes())
      .enter().append("svg:g");
    
    // A copy of the text with a thick white stroke for legibility.
    text.append("svg:text")
        .attr("x", 8)
        .attr("y", ".31em")
        .attr("class", "shadow")
        .text(function(d) { return d.name; });
    
    text.append("svg:text")
        .attr("x", 8)
        .attr("y", ".31em")
        .text(function(d) { return d.name; });
    
    // Use elliptical arc path segments to doubly-encode directionality.
    function tick() {
      path.attr("d", function(d) {
        var dx = d.target.x - d.source.x,
            dy = d.target.y - d.source.y,
            dr = Math.sqrt(dx * dx + dy * dy);
        return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
      });
    
      circle.attr("transform", function(d) {
        return "translate(" + d.x + "," + d.y + ")";
      });
    
      text.attr("transform", function(d) {
        return "translate(" + d.x + "," + d.y + ")";
      });
    };
    
    function update() {
      var nodes = flatten(root),
          links = d3.layout.tree().links(nodes);
    
      // Restart the force layout.
      force
          .nodes(nodes)
          .links(links)
          .start();
    
      // Update the links…
      link = vis.selectAll("line.link")
          .data(links, function(d) { return d.target.id; });
    
      // Enter any new links.
      link.enter().insert("svg:line", ".node")
          .attr("class", "link")
          .attr("x1", function(d) { return d.source.x; })
          .attr("y1", function(d) { return d.source.y; })
          .attr("x2", function(d) { return d.target.x; })
          .attr("y2", function(d) { return d.target.y; });
    
      // Exit any old links.
      link.exit().remove();
    
      // Update the nodes…
      node = vis.selectAll("circle.node")
          .data(nodes, function(d) { return d.id; })
          .style("fill", color);
    
      // Enter any new nodes.
      node.enter().append("svg:circle")
          .attr("class", "node")
          .attr("cx", function(d) { return d.x; })
          .attr("cy", function(d) { return d.y; })
          .attr("r", function(d) { return Math.sqrt(d.size) / 10 || 4.5; })
          .style("fill", color)
          .on("click", click)
          .call(force.drag);
    
      // Exit any old nodes.
      node.exit().remove();
    }
    
    // Toggle children on click.
    function click(d) {
      if (d.children) {
        d._children = d.children;
        d.children = null;
      } else {
        d.children = d._children;
        d._children = null;
      }
      update();
    }
    
    // Returns a list of all nodes under the root.
    function flatten(root) {
      var nodes = [], i = 0;
    
      function recurse(node) {
        if (node.children) node.children.forEach(recurse);
        if (!node.id) node.id = ++i;
        nodes.push(node);
      }
    
      recurse(root);
      return nodes;
    }
    });

    </script>
  </body>
</html>